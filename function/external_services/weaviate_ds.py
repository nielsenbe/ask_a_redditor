import logging
import weaviate
import os
from typing import Dict, List, Optional, Tuple
from datetime import datetime

from models.models import (
    QueryWithEmbedding,
)


WEAVIATE_HOST = os.environ.get("WEAVIATE_HOST", "http://127.0.0.1")
WEAVIATE_KEY = os.environ.get("WEAVIATE_KEY", None)
WEAVIATE_INDEX = os.environ.get("WEAVIATE_INDEX", "ASKAREDDITOR")

WEAVIATE_BATCH_SIZE = int(os.environ.get("WEAVIATE_BATCH_SIZE", 20))
WEAVIATE_BATCH_DYNAMIC = os.environ.get("WEAVIATE_BATCH_DYNAMIC", False)
WEAVIATE_BATCH_TIMEOUT_RETRIES = int(os.environ.get("WEAVIATE_TIMEOUT_RETRIES", 3))
WEAVIATE_BATCH_NUM_WORKERS = int(os.environ.get("WEAVIATE_BATCH_NUM_WORKERS", 1))



def _handle_errors(results: Optional[List[dict]]) -> List[str]:
        """
        Formats errors generated by the Weaviate service.
        """
        if not results:
            return []

        error_messages = []
        for result in results:
            if (
                "result" not in result
                or "errors" not in result["result"]
                or "error" not in result["result"]["errors"]
            ):
                continue
            for message in result["result"]["errors"]["error"]:
                error_messages.append(message["message"])
                logging.exception(message["message"])

        return error_messages


def _build_filters(filter):
    """
    Converts OpenAI filters to Weaviate filters.
    """
    operands = []
    filter_conditions = {
        "start_date": {"operator": "GreaterThanEqual", "value_key": "valueDate"},
        "end_date": {"operator": "LessThanEqual", "value_key": "valueDate"},
        "default": {"operator": "Equal", "value_key": "valueString"},
    }

    for attr, value in filter.__dict__.items():
        if value is not None:
            filter_condition = filter_conditions.get(
                attr, filter_conditions["default"]
            )
            value_key = filter_condition["value_key"]

            operand = {
                "path": [
                    attr
                    if not (attr == "start_date" or attr == "end_date")
                    else "question_datetime"
                ],
                "operator": filter_condition["operator"],
                value_key: value if attr not in ['start_date', 'end_date'] else int(datetime.strptime(value, "%Y-%m-%dT%H:%M:%SZ").timestamp()),
            }

            operands.append(operand)

    return {"operator": "And", "operands": operands}


def _single_query(client: weaviate.Client, query: QueryWithEmbedding) -> List[dict]:
    wv_query = (
        client.query.get(
            WEAVIATE_INDEX,
            [
                "question_id",
                "question",
                "question_author",
                "question_subreddit",
                "question_url",
                "question_marked_nsfw",
                "question_datetime",
                "answer_id",
                "answer",
                "answer_url",
                "answer_author",
                "answer_commentary",
                "score_weighted_final"
            ],
        )
        .with_hybrid(query=query.query, alpha=0.5, vector=query.embedding)
        .with_limit(query.top_k)  # type: ignore
        .with_additional(["score", "vector"]))
    
    if hasattr(query, "filter") and query.filter:
        filters_ = _build_filters(query.filter)
        wv_query = wv_query.with_where(filters_)

    result = wv_query.do()
    response = result["data"]["Get"][WEAVIATE_INDEX]

    return response


def query(queries: List[QueryWithEmbedding],) -> List[Tuple[str, List[Dict]]]:
    """
    Takes in a list of queries with embeddings and filters and returns a list of query results with matching document chunks and scores.
    """
    auth_config = weaviate.auth.AuthApiKey(api_key=WEAVIATE_KEY)
    client = weaviate.Client(WEAVIATE_HOST, auth_client_secret=auth_config)
    client.batch.configure(
            batch_size=WEAVIATE_BATCH_SIZE,
            dynamic=WEAVIATE_BATCH_DYNAMIC,  # type: ignore
            callback=_handle_errors,  # type: ignore
            timeout_retries=WEAVIATE_BATCH_TIMEOUT_RETRIES,
            num_workers=WEAVIATE_BATCH_NUM_WORKERS,
        )
    
    return [(query.query, _single_query(client, query)) for query in queries]